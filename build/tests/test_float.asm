*
* Generated by CC Compiler - HLASM Backend
*
CCPROG   CSECT
         USING *,12
*
*
* Function: add_doubles
* Convenção z/OS: R1=param list, R13=save area, R14=return, R15=entry
*
add_doubles DS    0H
         STM   14,12,12(13)      Save registers R14-R12
         LR    12,15             Establish base register
         USING add_doubles,12
         LR    11,13             Save caller's save area in R11
         LA    13,SAVEadd_doubles         Get our save area
         ST    11,4(,13)         Chain: our->prev = caller's
         ST    13,8(,11)         Chain: caller->next = ours
         LR    11,13             R11 = frame pointer (ebp)
*        R1 contains parameter list pointer
*        Parameters accessed via: L Rx,0(,1) for 1st, L Rx,4(,1) for 2nd, etc.
         LD    0,80(,11)        Load double BFP from stack
         ADB   0,88(,11)        Add double BFP from stack
*        Return: R15 contains return code, F0 for float/double
         LR    15,2              Copy return value to R15
         L     13,4(,13)         Restore caller's save area
         LM    14,12,12(13)      Restore registers R14-R12
         BR    14                Return to caller
*
* Function: sub_doubles
* Convenção z/OS: R1=param list, R13=save area, R14=return, R15=entry
*
sub_doubles DS    0H
         STM   14,12,12(13)      Save registers R14-R12
         LR    12,15             Establish base register
         USING sub_doubles,12
         LR    11,13             Save caller's save area in R11
         LA    13,SAVEsub_doubles         Get our save area
         ST    11,4(,13)         Chain: our->prev = caller's
         ST    13,8(,11)         Chain: caller->next = ours
         LR    11,13             R11 = frame pointer (ebp)
*        R1 contains parameter list pointer
*        Parameters accessed via: L Rx,0(,1) for 1st, L Rx,4(,1) for 2nd, etc.
         LD    0,80(,11)        Load double BFP from stack
         SDB   0,88(,11)        Sub double BFP from stack
*        Return: R15 contains return code, F0 for float/double
         LR    15,2              Copy return value to R15
         L     13,4(,13)         Restore caller's save area
         LM    14,12,12(13)      Restore registers R14-R12
         BR    14                Return to caller
*
* Function: mul_doubles
* Convenção z/OS: R1=param list, R13=save area, R14=return, R15=entry
*
mul_doubles DS    0H
         STM   14,12,12(13)      Save registers R14-R12
         LR    12,15             Establish base register
         USING mul_doubles,12
         LR    11,13             Save caller's save area in R11
         LA    13,SAVEmul_doubles         Get our save area
         ST    11,4(,13)         Chain: our->prev = caller's
         ST    13,8(,11)         Chain: caller->next = ours
         LR    11,13             R11 = frame pointer (ebp)
*        R1 contains parameter list pointer
*        Parameters accessed via: L Rx,0(,1) for 1st, L Rx,4(,1) for 2nd, etc.
         LD    0,80(,11)        Load double BFP from stack
         MDB   0,88(,11)        Mul double BFP from stack
*        Return: R15 contains return code, F0 for float/double
         LR    15,2              Copy return value to R15
         L     13,4(,13)         Restore caller's save area
         LM    14,12,12(13)      Restore registers R14-R12
         BR    14                Return to caller
*
* Function: div_doubles
* Convenção z/OS: R1=param list, R13=save area, R14=return, R15=entry
*
div_doubles DS    0H
         STM   14,12,12(13)      Save registers R14-R12
         LR    12,15             Establish base register
         USING div_doubles,12
         LR    11,13             Save caller's save area in R11
         LA    13,SAVEdiv_doubles         Get our save area
         ST    11,4(,13)         Chain: our->prev = caller's
         ST    13,8(,11)         Chain: caller->next = ours
         LR    11,13             R11 = frame pointer (ebp)
*        R1 contains parameter list pointer
*        Parameters accessed via: L Rx,0(,1) for 1st, L Rx,4(,1) for 2nd, etc.
         LD    0,80(,11)        Load double BFP from stack
         DDB   0,88(,11)        Div double BFP from stack
*        Return: R15 contains return code, F0 for float/double
         LR    15,2              Copy return value to R15
         L     13,4(,13)         Restore caller's save area
         LM    14,12,12(13)      Restore registers R14-R12
         BR    14                Return to caller
*
* Function: negate_double
* Convenção z/OS: R1=param list, R13=save area, R14=return, R15=entry
*
negate_double DS    0H
         STM   14,12,12(13)      Save registers R14-R12
         LR    12,15             Establish base register
         USING negate_double,12
         LR    11,13             Save caller's save area in R11
         LA    13,SAVEnegate_double         Get our save area
         ST    11,4(,13)         Chain: our->prev = caller's
         ST    13,8(,11)         Chain: caller->next = ours
         LR    11,13             R11 = frame pointer (ebp)
*        R1 contains parameter list pointer
*        Parameters accessed via: L Rx,0(,1) for 1st, L Rx,4(,1) for 2nd, etc.
         LD    0,80(,11)        Load double BFP from stack
         LCDBR 0,0              Negate F0 (BFP)
*        Return: R15 contains return code, F0 for float/double
         LR    15,2              Copy return value to R15
         L     13,4(,13)         Restore caller's save area
         LM    14,12,12(13)      Restore registers R14-R12
         BR    14                Return to caller
*
* Function: double_to_int
* Convenção z/OS: R1=param list, R13=save area, R14=return, R15=entry
*
double_to_int DS    0H
         STM   14,12,12(13)      Save registers R14-R12
         LR    12,15             Establish base register
         USING double_to_int,12
         LR    11,13             Save caller's save area in R11
         LA    13,SAVEdouble_to_int         Get our save area
         ST    11,4(,13)         Chain: our->prev = caller's
         ST    13,8(,11)         Chain: caller->next = ours
         LR    11,13             R11 = frame pointer (ebp)
*        R1 contains parameter list pointer
*        Parameters accessed via: L Rx,0(,1) for 1st, L Rx,4(,1) for 2nd, etc.
         LD    0,80(,11)        Load double BFP from stack
* FPU control word - not applicable to z/Arch
         CFDBR 0,5,0            Convert long BFP to fixed (truncate)
         ST    0,-4(,13)        Store integer to stack
         L     2,-4(,13)        Load from stack
* FPU control word - not applicable to z/Arch
*        Return: R15 contains return code, F0 for float/double
         LR    15,2              Copy return value to R15
         L     13,4(,13)         Restore caller's save area
         LM    14,12,12(13)      Restore registers R14-R12
         BR    14                Return to caller
*
* Function: int_to_double
* Convenção z/OS: R1=param list, R13=save area, R14=return, R15=entry
*
int_to_double DS    0H
         STM   14,12,12(13)      Save registers R14-R12
         LR    12,15             Establish base register
         USING int_to_double,12
         LR    11,13             Save caller's save area in R11
         LA    13,SAVEint_to_double         Get our save area
         ST    11,4(,13)         Chain: our->prev = caller's
         ST    13,8(,11)         Chain: caller->next = ours
         LR    11,13             R11 = frame pointer (ebp)
*        R1 contains parameter list pointer
*        Parameters accessed via: L Rx,0(,1) for 1st, L Rx,4(,1) for 2nd, etc.
         L     2,80(,11)
         ST    2,-4(,13)        Store to stack
         L     0,-4(,13)        Load integer from stack
         CDFBR 0,0              Convert fixed to long BFP
*        Return: R15 contains return code, F0 for float/double
         LR    15,2              Copy return value to R15
         L     13,4(,13)         Restore caller's save area
         LM    14,12,12(13)      Restore registers R14-R12
         BR    14                Return to caller
*
* Function: main
* Convenção z/OS: R1=param list, R13=save area, R14=return, R15=entry
*
main     DS    0H
         STM   14,12,12(13)      Save registers R14-R12
         LR    12,15             Establish base register
         USING main,12
         LR    11,13             Save caller's save area in R11
         LA    13,SAVEmain         Get our save area
         ST    11,4(,13)         Chain: our->prev = caller's
         ST    13,8(,11)         Chain: caller->next = ours
         LR    11,13             R11 = frame pointer (ebp)
*        R1 contains parameter list pointer
*        Parameters accessed via: L Rx,0(,1) for 1st, L Rx,4(,1) for 2nd, etc.
         AHI   13,-72
         LD    0,=DB'0'        Load double BFP constant
         STD   0,64(,11)        Store double to stack
         LDR   2,0              Copy F0 to F2 (pop)
         LD    0,=DB'8'        Load double BFP constant
         STD   0,56(,11)        Store double to stack
         LDR   2,0              Copy F0 to F2 (pop)
         LD    0,56(,11)        Load double BFP from stack
         AHI   13,-8
         STD   0,0(,13)         Store and pop to stack
         LD    0,64(,11)        Load double BFP from stack
         AHI   13,-8
         STD   0,0(,13)         Store and pop to stack
*        Call function: add_doubles
         L     15,=V(add_doubles)      Load function address
         BALR  14,15            Call function
         LR    2,15             Copy return value to R2 (eax)
         AHI   13,16
         LDR   2,0              Copy F0 to F2 (pop)
         STD   0,48(,11)        Store double to stack
         LDR   2,0              Copy F0 to F2 (pop)
         LD    0,56(,11)        Load double BFP from stack
         AHI   13,-8
         STD   0,0(,13)         Store and pop to stack
         LD    0,64(,11)        Load double BFP from stack
         AHI   13,-8
         STD   0,0(,13)         Store and pop to stack
*        Call function: sub_doubles
         L     15,=V(sub_doubles)      Load function address
         BALR  14,15            Call function
         LR    2,15             Copy return value to R2 (eax)
         AHI   13,16
         LDR   2,0              Copy F0 to F2 (pop)
         STD   0,40(,11)        Store double to stack
         LDR   2,0              Copy F0 to F2 (pop)
         LD    0,56(,11)        Load double BFP from stack
         AHI   13,-8
         STD   0,0(,13)         Store and pop to stack
         LD    0,64(,11)        Load double BFP from stack
         AHI   13,-8
         STD   0,0(,13)         Store and pop to stack
*        Call function: mul_doubles
         L     15,=V(mul_doubles)      Load function address
         BALR  14,15            Call function
         LR    2,15             Copy return value to R2 (eax)
         AHI   13,16
         LDR   2,0              Copy F0 to F2 (pop)
         STD   0,32(,11)        Store double to stack
         LDR   2,0              Copy F0 to F2 (pop)
         LD    0,56(,11)        Load double BFP from stack
         AHI   13,-8
         STD   0,0(,13)         Store and pop to stack
         LD    0,64(,11)        Load double BFP from stack
         AHI   13,-8
         STD   0,0(,13)         Store and pop to stack
*        Call function: div_doubles
         L     15,=V(div_doubles)      Load function address
         BALR  14,15            Call function
         LR    2,15             Copy return value to R2 (eax)
         AHI   13,16
         LDR   2,0              Copy F0 to F2 (pop)
         STD   0,24(,11)        Store double to stack
         LDR   2,0              Copy F0 to F2 (pop)
         LD    0,64(,11)        Load double BFP from stack
         AHI   13,-8
         STD   0,0(,13)         Store and pop to stack
*        Call function: negate_double
         L     15,=V(negate_double)      Load function address
         BALR  14,15            Call function
         LR    2,15             Copy return value to R2 (eax)
         AHI   13,8
         LDR   2,0              Copy F0 to F2 (pop)
         STD   0,16(,11)        Store double to stack
         LDR   2,0              Copy F0 to F2 (pop)
         LD    0,64(,11)        Load double BFP from stack
         AHI   13,-8
         STD   0,0(,13)         Store and pop to stack
*        Call function: double_to_int
         L     15,=V(double_to_int)      Load function address
         BALR  14,15            Call function
         LR    2,15             Copy return value to R2 (eax)
         AHI   13,8
         ST    2,12(,11)
         LA    2,42
         LA    0,PLIST+0       Param slot address
         ST    2,0(,0)          Store param value
*        Call function: int_to_double
         LA    1,PLIST         R1 -> parameter list
         OI    PLIST+0,X'80'  Set VL bit on last param
         L     15,=V(int_to_double)      Load function address
         BALR  14,15            Call function
         LR    2,15             Copy return value to R2 (eax)
         AHI   13,4
         LDR   2,0              Copy F0 to F2 (pop)
         STD   0,0(,11)        Store double to stack
         LDR   2,0              Copy F0 to F2 (pop)
         LA    2,0
*        Return: R15 contains return code, F0 for float/double
         LR    15,2              Copy return value to R15
         L     13,4(,13)         Restore caller's save area
         LM    14,12,12(13)      Restore registers R14-R12
         BR    14                Return to caller
*
* Function: _main
* Convenção z/OS: R1=param list, R13=save area, R14=return, R15=entry
*
_main    DS    0H
         STM   14,12,12(13)      Save registers R14-R12
         LR    12,15             Establish base register
         USING _main,12
         LR    11,13             Save caller's save area in R11
         LA    13,SAVE_main         Get our save area
         ST    11,4(,13)         Chain: our->prev = caller's
         ST    13,8(,11)         Chain: caller->next = ours
         LR    11,13             R11 = frame pointer (ebp)
*        R1 contains parameter list pointer
*        Parameters accessed via: L Rx,0(,1) for 1st, L Rx,4(,1) for 2nd, etc.
         AHI   13,-4
*        Call function: main
         L     15,=V(main)      Load function address
         BALR  14,15            Call function
         LR    2,15             Copy return value to R2 (eax)
         ST    2,68(,11)
*        Return: R15 contains return code, F0 for float/double
         LR    15,2              Copy return value to R15
         L     13,4(,13)         Restore caller's save area
         LM    14,12,12(13)      Restore registers R14-R12
         BR    14                Return to caller
*
* Data Section
*
         DC    DB'10.500000'
         DC    DB'3.200000'
*
* Work Areas
*
SAVEAREA DS    18F               Register save area (72 bytes)
PLIST    DS    16F               Parameter list (up to 16 params)
FTEMP    DS    D                 Temp for float conversions
ITEMP    DS    F                 Temp for integer conversions
*
* Function-specific save areas
*
SAVEadd_doubles DS    18F               Save area for add_doubles
SAVEsub_doubles DS    18F               Save area for sub_doubles
SAVEmul_doubles DS    18F               Save area for mul_doubles
SAVEdiv_doubles DS    18F               Save area for div_doubles
SAVEnegate_double DS    18F               Save area for negate_double
SAVEdouble_to_int DS    18F               Save area for double_to_int
SAVEint_to_double DS    18F               Save area for int_to_double
SAVEmain DS    18F               Save area for main
SAVE_main DS    18F               Save area for _main
*
         LTORG                   Literal pool
*
*--------------------------------------------------------------------
* Notas sobre instruções de conversão:
* CDFBR F1,R2 - Convert from Fixed 32-bit to Long BFP (double)
* CFDBR R1,M3,F2 - Convert to Fixed 32-bit from Long BFP
*   M3=0: Use current rounding mode
*   M3=1: Round to nearest (ties to even)
*   M3=5: Round toward zero (truncate)
*   M3=6: Round toward +infinity
*   M3=7: Round toward -infinity
* Estas instruções requerem z/Architecture (z900+)
*--------------------------------------------------------------------
         END   CCPROG
